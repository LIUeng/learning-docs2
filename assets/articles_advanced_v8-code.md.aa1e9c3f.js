import{_ as a,o as e,c as l,Q as i}from"./chunks/framework.0e8ae64e.js";const o="/assets/images/compiler.jpg",t="/assets/images/v8-code.jpg",m=JSON.parse('{"title":"V8","description":"","frontmatter":{},"headers":[],"relativePath":"articles/advanced/v8-code.md","filePath":"articles/advanced/v8-code.md","lastUpdated":1670379203000}'),r={name:"articles/advanced/v8-code.md"},c=i('<h1 id="v8" tabindex="-1">V8 <a class="header-anchor" href="#v8" aria-label="Permalink to &quot;V8&quot;">​</a></h1><h2 id="解释器和执行器" tabindex="-1">解释器和执行器 <a class="header-anchor" href="#解释器和执行器" aria-label="Permalink to &quot;解释器和执行器&quot;">​</a></h2><img src="'+o+'" alt="解释器和执行器"><ul><li><p>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功</p></li><li><p>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果</p></li></ul><h2 id="v8-执行代码" tabindex="-1">V8 执行代码 <a class="header-anchor" href="#v8-执行代码" aria-label="Permalink to &quot;V8 执行代码&quot;">​</a></h2><img src="'+t+'" alt="v8 执行代码"><h3 id="生成抽象语法树和执行上下文" tabindex="-1">生成抽象语法树和执行上下文 <a class="header-anchor" href="#生成抽象语法树和执行上下文" aria-label="Permalink to &quot;生成抽象语法树和执行上下文&quot;">​</a></h3><ul><li>分词（tokenize），词法分析</li></ul><p>将源码拆成一个个 token（语法上不能再分的、最小的单个字符或字符串）</p><ul><li>解析（parse），语法分析</li></ul><p>将上一步生成的 token 数据，根据语法规则转成抽象语法树（存在语法错误，会终止抛出错误）</p><h3 id="生成字节码" tabindex="-1">生成字节码 <a class="header-anchor" href="#生成字节码" aria-label="Permalink to &quot;生成字节码&quot;">​</a></h3><p>字节码是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行（体积小）</p><h3 id="执行代码" tabindex="-1">执行代码 <a class="header-anchor" href="#执行代码" aria-label="Permalink to &quot;执行代码&quot;">​</a></h3><p>解释器 Ignition</p><ul><li>第一次执行的字节码，解释器逐条解释执行</li><li>解释器解析生成字节码，还有一个作用就是解释执行字节码</li><li>执行字节码过程中，有热点代码（重复执行多次），后台编译器（TurboFan）把这段代码编译成机器码，提高执行效率</li></ul><p><code>JIT 即时编译</code></p><p>解释器 Ignition 在解释执行字节码的同时，收集代码信息，发现是热点代码之后，TurboFan 编译器把热点的字节码编译成机器码，并保存起来以供下次使用</p><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2><p><a href="https://time.geekbang.org/column/article/131233" target="_blank" rel="noreferrer">V8 的垃圾回收</a></p><h3 id="栈空间" tabindex="-1">栈空间 <a class="header-anchor" href="#栈空间" aria-label="Permalink to &quot;栈空间&quot;">​</a></h3><p>原始数据类型存放与栈空间中</p><p><code>函数执行上下文 -&gt; 全局执行上下文（采用调用栈的形式记录数据）</code></p><h3 id="堆空间" tabindex="-1">堆空间 <a class="header-anchor" href="#堆空间" aria-label="Permalink to &quot;堆空间&quot;">​</a></h3><p>引用类型使用堆空间存储（栈中存储的是引用地址）</p><h3 id="堆空间的垃圾回收" tabindex="-1">堆空间的垃圾回收 <a class="header-anchor" href="#堆空间的垃圾回收" aria-label="Permalink to &quot;堆空间的垃圾回收&quot;">​</a></h3><blockquote><p>代际假说</p></blockquote><ol><li>对象一般不会存储太久，一经分配内存，很快就会变得不可访问</li><li>不死的对象活的更久</li></ol><h3 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h3><p>对象存放的时间较短（1-8M 的存储空间）</p><h3 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h3><p>对象存放的时间较长</p><h3 id="垃圾回收流程" tabindex="-1">垃圾回收流程 <a class="header-anchor" href="#垃圾回收流程" aria-label="Permalink to &quot;垃圾回收流程&quot;">​</a></h3><p>所有垃圾回收机制，都有一套完整的统一流程</p><ul><li>标记空间中的活动对象和非活动对象 <ul><li>活动对象 = 正在使用中的对象</li><li>非活动对象 = 需要垃圾回收的对象</li></ul></li><li>回收非活动对象占用的空间 <ul><li>所有标记完成之后，统一清理内存中所有被标记为可回收的对象</li></ul></li><li>内存整理 <ul><li>整理内存碎片（不连续的内存空间）</li></ul></li></ul><h3 id="副垃圾回收器" tabindex="-1">副垃圾回收器 <a class="header-anchor" href="#副垃圾回收器" aria-label="Permalink to &quot;副垃圾回收器&quot;">​</a></h3><p>主要负责新生代区间的垃圾回收</p><blockquote><p>Scanvenge 算法 -&gt; 新生区区间划分为两个区域：对象区域、空闲区域</p></blockquote><ul><li><p>新加入的对象会加入对象区域，对象区域存满之后，会执行一次垃圾回收操作</p></li><li><p>对对象区域中的垃圾进行标记</p></li><li><p>标记完毕，副垃圾回收器会对没有进行标记的对象进行复制，<code>复制</code>到空闲区域，同时还会排列起来（内存整理）</p></li><li><p>对象区域和空闲区域角色反转（对象区域=空闲区域 空闲区域=对象区域）两块区域重复利用</p></li></ul><blockquote><p>对象晋升策略</p></blockquote><p>为了执行效率，新生代的空间一般不会设置得太大，因此<code>经过两次垃圾回收的活动对象依然存在</code>，会被放入到老生代区间中</p><h3 id="主垃圾回收器" tabindex="-1">主垃圾回收器 <a class="header-anchor" href="#主垃圾回收器" aria-label="Permalink to &quot;主垃圾回收器&quot;">​</a></h3><p>主要负责老生代区间的垃圾回收</p><ul><li>空间大</li><li>对象存活时间长</li></ul><blockquote><p>标记 - 清除（Mark - Sweep）</p></blockquote><ul><li>从一组根元素开始</li><li>递归遍历根元素（能访问到的元素为活动对象，不能访问到的元素为垃圾数据）</li></ul><blockquote><p>标记 - 整理（Mark - Compact）</p></blockquote><p>标记清除算法会产生大量的不连续内存碎片，导致大对象无法分配一块连续空间的内存</p><ul><li>所有的活动对象都向一端移动，然后直接清理掉端边界以外的内存</li></ul><h3 id="全停顿" tabindex="-1">全停顿 <a class="header-anchor" href="#全停顿" aria-label="Permalink to &quot;全停顿&quot;">​</a></h3><p>Stop-The-World</p><p><code>JavaScript 是运行在主线程之上，一旦执行垃圾回收算法，脚本执行需要停顿，待垃圾回收完毕之后恢复脚本的执行</code></p><h3 id="增量标记" tabindex="-1">增量标记 <a class="header-anchor" href="#增量标记" aria-label="Permalink to &quot;增量标记&quot;">​</a></h3><p>Incremental Marking</p><p>全停顿算法，一旦垃圾回收算法执行时间过长，页面会出现卡顿现象，导致用户体验下降</p><ul><li>一个完整的垃圾回收任务拆分成很小的任务</li><li>小任务执行时间很短，穿插在 JavaScript 任务中</li></ul>',56),h=[c];function n(d,p,u,s,b,q){return e(),l("div",null,h)}const _=a(r,[["render",n]]);export{m as __pageData,_ as default};
