import{_ as a,o as e,c as o,Q as l}from"./chunks/framework.7c0fadea.js";const b=JSON.parse('{"title":"网络模型","description":"","frontmatter":{},"headers":[],"relativePath":"network/osi.md","filePath":"network/osi.md","lastUpdated":1670330848000}'),i={name:"network/osi.md"},t=l('<h1 id="网络模型" tabindex="-1">网络模型 <a class="header-anchor" href="#网络模型" aria-label="Permalink to &quot;网络模型&quot;">​</a></h1><h2 id="网络传输协议" tabindex="-1">网络传输协议 <a class="header-anchor" href="#网络传输协议" aria-label="Permalink to &quot;网络传输协议&quot;">​</a></h2><p><code>Communications Protocol</code></p><p>在任何物理介质中允许两个或多个在传输系统中的终端之间传播信息的系统标准，计算机通信或网上设备的共同语言</p><h2 id="osi-网络模型" tabindex="-1">OSI 网络模型 <a class="header-anchor" href="#osi-网络模型" aria-label="Permalink to &quot;OSI 网络模型&quot;">​</a></h2><p>OSI（open system interconnect）</p><h3 id="应用层" tabindex="-1">应用层 <a class="header-anchor" href="#应用层" aria-label="Permalink to &quot;应用层&quot;">​</a></h3><p><code>Application Layer</code></p><p>提供为应用软件而设的接口，以设置与另一应用软件之间的通信（HTTP, HTTPS, FTP, TELNET, SSH, SMTP, POP3）</p><h3 id="表达层" tabindex="-1">表达层 <a class="header-anchor" href="#表达层" aria-label="Permalink to &quot;表达层&quot;">​</a></h3><p><code>Presentation Layer</code></p><p>把数据转换为能与接收者的系统格式兼容并适合传输的格式</p><h3 id="会话层" tabindex="-1">会话层 <a class="header-anchor" href="#会话层" aria-label="Permalink to &quot;会话层&quot;">​</a></h3><p><code>Session Layer</code></p><p>在数据传输中设置和维护计算机网络中两台计算机之间的通信连接</p><h3 id="传输层" tabindex="-1">传输层 <a class="header-anchor" href="#传输层" aria-label="Permalink to &quot;传输层&quot;">​</a></h3><p><code>Transport Layer</code></p><p>把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息（TCP）</p><h3 id="网络层" tabindex="-1">网络层 <a class="header-anchor" href="#网络层" aria-label="Permalink to &quot;网络层&quot;">​</a></h3><p><code>Network Layer</code></p><p>决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组，网络表头包含了网络数据（IP 协议）</p><h3 id="数据链路层" tabindex="-1">数据链路层 <a class="header-anchor" href="#数据链路层" aria-label="Permalink to &quot;数据链路层&quot;">​</a></h3><p><code>Data Link Layer</code></p><p>负责网络寻址、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串（以太网、WiFi、GPRS）</p><ul><li>逻辑链路控制子层(login link control, LLC)</li><li>介质访问控制子层(mdia access control, MAC)</li></ul><h3 id="物理层" tabindex="-1">物理层 <a class="header-anchor" href="#物理层" aria-label="Permalink to &quot;物理层&quot;">​</a></h3><p><code>Physical Layer</code></p><p>在局部局域网上传输数据帧，负责管理计算机通信设备和网络媒体之间的互通（针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器）</p><h2 id="tcp-ip-协议" tabindex="-1">TCP/IP 协议 <a class="header-anchor" href="#tcp-ip-协议" aria-label="Permalink to &quot;TCP/IP 协议&quot;">​</a></h2><p><code>Transmission Control Protocol/Internet Protocol</code> 传输控制协议/网际协议</p><p>能够在多个不同网络间实现信息传输的协议簇（TCP IP FTP SMTP UDP)</p><blockquote><p>TCP/IP 的四层架构模型</p></blockquote><h3 id="链路层" tabindex="-1">链路层 <a class="header-anchor" href="#链路层" aria-label="Permalink to &quot;链路层&quot;">​</a></h3><p>对电信号进行分组形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方</p><ul><li>网卡 --- 数据包必须是一块网卡传送到另一块网卡</li><li>主机读取 MAC 地址，处理接收包</li></ul><h3 id="网络层-1" tabindex="-1">网络层 <a class="header-anchor" href="#网络层-1" aria-label="Permalink to &quot;网络层&quot;">​</a></h3><ul><li>IP 协议</li></ul><blockquote><p>引入 IP 协议，制定了一套新地址，区分两台主机是否属于同一网络（网络地址 IP 地址）</p></blockquote><ul><li>ARP 协议</li></ul><blockquote><p>根据 IP 地址获取 MAC 地址的一个网络层协议</p></blockquote><ol><li>发起请求数据包，IP 地址 + 请求数据包，生成以太网数据包，广播</li><li>主机收到数据包，取出 IP 地址，与自己的 IP 地址对比，相同则返回 MAC 地址</li><li>接收返回消息，确定 MAC 地址</li><li>缓存（ARP 缓存返回的 MAC 地址 + IP 地址对应保留一定时间，以防下次请求）</li></ol><ul><li>路由协议</li></ul><blockquote><p>ARP 获取 MAC 地址完成这个路由协议的物理设备就是路由器（交通枢纽）=== 定义网络地址、区分网段、子网内 MAC 寻址、对于不同子网的数据包进行路由</p></blockquote><ul><li>ICMP 协议</li></ul><blockquote><p>因特网控制报文协议，主机与路由器之间进行控制信息传递（检查网络是否通畅、主机是否可达、路由是否可用）出现错误，自动返回错误的信息</p></blockquote><h3 id="传输层-1" tabindex="-1">传输层 <a class="header-anchor" href="#传输层-1" aria-label="Permalink to &quot;传输层&quot;">​</a></h3><p>数据包被发送到主机上以后，是无法确定哪个应用程序要接收这个包（为应用程序标识身份，定义端口）</p><ul><li>UDP 协议</li></ul><blockquote><p>定义了端口，同一个主机上的每个应用程序都需要指定唯一的端口号，传输指定端口（传输性较差）</p></blockquote><ul><li>TCP 协议</li></ul><blockquote><p>传输控制协议，面向链接的，可靠的，基于字节流的通信协议（TCP 确认机制的 UDP 协议）</p></blockquote><ol><li>数据包丢失，无法收到确认，重新发送数据包</li><li>三次对话的确认机制</li><li>首部 + 数据（TCP 数据包没有长度限制，TCP 数据包的长度不会超过 IP 数据包的长度，不必分割）</li></ol><h3 id="应用层-1" tabindex="-1">应用层 <a class="header-anchor" href="#应用层-1" aria-label="Permalink to &quot;应用层&quot;">​</a></h3><p>HTTP FTP SMTP</p><blockquote><p>定义数据格式并按照对应的格式解读数据</p></blockquote><p>请求 Header 中，定义请求数据格式 Accept 和响应数据格式 Content-Type</p><h3 id="缺陷" tabindex="-1">缺陷 <a class="header-anchor" href="#缺陷" aria-label="Permalink to &quot;缺陷&quot;">​</a></h3><ol><li>没有明显地区区分服务、接口和协议的概念</li><li>不通用，不适用与 TCP/IP 模型之外的任何协议栈</li><li>链路层不是通常意义的一层（一个接口处于网络层和数据链路层之间）</li><li>TCP/IP 模型不区分物理层和数据链路层</li></ol>',58),r=[t];function c(n,h,p,d,s,P){return e(),o("div",null,r)}const q=a(i,[["render",c]]);export{b as __pageData,q as default};
