import{_ as l,o as s,c as o,Q as a}from"./chunks/framework.0e8ae64e.js";const E=JSON.parse('{"title":"History API","description":"","frontmatter":{},"headers":[],"relativePath":"articles/basic/history.md","filePath":"articles/basic/history.md","lastUpdated":1670330848000}'),n={name:"articles/basic/history.md"},t=a(`<h1 id="history-api" tabindex="-1">History API <a class="header-anchor" href="#history-api" aria-label="Permalink to &quot;History API&quot;">​</a></h1><h2 id="window-history" tabindex="-1">window.history <a class="header-anchor" href="#window-history" aria-label="Permalink to &quot;window.history&quot;">​</a></h2><ul><li>back Function 后退一页</li><li>forward Function 前进一页</li><li>go Function(Number) | String)</li></ul><ol><li>负数 history.go(-1) 后退一页</li><li>正数 history.go(2) 前进两页</li><li>参数为字符串时，跳到最近的页面（可能后退也可能前进）history.go(&#39;google.com&#39;);</li></ol><ul><li>pushState Function</li></ul><ol><li>接收三个参数：状态对象、新状态的标题（浏览器暂未实现）、相对地址 url</li><li>会创建新的历史状态</li></ol><ul><li>replaceState Function</li></ul><ol><li>接收三个参数：状态对象、新状态的标题（浏览器暂未实现）、相对地址 url</li><li>更新当前页面的历史状态，不会计入历史状态</li></ol><blockquote><p>手动调用 pushState，window history 对象每切换不同的页面长度(前进后退) length + 1，replaceState 则不会</p></blockquote><ul><li>state</li></ul><p><code>页面的 history 状态，可以使用 history.state 获取，设置 state 为调用 pushState, replaceState 的第一个参数状态对象</code></p><ul><li>scrollRestoration</li></ul><ol><li>允许 web 应用在历史记录导航上设置默认滚动行为</li><li>取值：auto manual 默认值为 auto</li></ol><h2 id="browser-浏览器路由" tabindex="-1">Browser 浏览器路由 <a class="header-anchor" href="#browser-浏览器路由" aria-label="Permalink to &quot;Browser 浏览器路由&quot;">​</a></h2><p><code>单页应用，浏览器路由需要配合服务端配置</code></p><ul><li>nginx</li></ul><div class="language-nginx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">location</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">/ </span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;"> try_files </span><span style="color:#E1E4E8;">$uri $uri/ /index.html;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">location</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">/ </span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;"> try_files </span><span style="color:#24292E;">$uri $uri/ /index.html;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>popstate 事件</li></ul><p>浏览器后退前进按钮会触发 popstate 事件，进行路由的处理</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;popstate&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {}, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;popstate&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {}, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);</span></span></code></pre></div><h2 id="hash-哈希路由" tabindex="-1">Hash 哈希路由 <a class="header-anchor" href="#hash-哈希路由" aria-label="Permalink to &quot;Hash 哈希路由&quot;">​</a></h2><p><code>无需服务端配置，路由url加上 # 标志符</code></p><ul><li>hashchange 事件</li></ul><p>监听路由 hash 变化触发事件</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;hashchange&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;hashchange&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {});</span></span></code></pre></div><h2 id="window-location" tabindex="-1">window.location <a class="header-anchor" href="#window-location" aria-label="Permalink to &quot;window.location&quot;">​</a></h2><ul><li>hash 返回 url 的 hash（#后接 0 个或者多个字符），如果不包括散列，则返回空字符串</li><li>host 返回服务器域名 + 端口号（if has)</li><li>hostname 服务器域名</li><li>href 当前页面完整 url，location 对象的 toString()方法也返回完整 url</li><li>pathname 返回 url 中的目录和文件名</li><li>port 端口号</li><li>protocol 协议 http: | https:</li><li>search 返回 url 的查询字符串 ?开头</li><li>reload Function</li></ul><p><code>location.reload() 重新加载页面</code></p><ul><li>replace Function</li></ul><p><code>location.replace() 不会在历史记录中生成新的记录，history对象中长度length属性保持不变</code></p><ul><li>assign Function(String)</li></ul><p>打开新的 url 地址并生成一条新的历史记录，history 对象 length 属性 + 1</p><ol><li>location.href = &#39;google.com&#39;</li><li>window.location = &#39;google.com&#39;</li><li>location.assign(&#39;google.com&#39;)</li></ol><blockquote><p>以上三种方式同样效果</p></blockquote><ul><li>URL 重新加载方式</li></ul><ol><li>location.search = &#39;&#39;</li><li>location.hostname = &#39;&#39;</li><li>location.pathname = &#39;&#39;</li><li>location.port = &#39;&#39;</li></ol><blockquote><p>以上方式都会生成浏览器新的历史记录</p></blockquote><ul><li>URL 改变不会重载</li></ul><p><code>location.hash = &#39;&#39; 这种方式不会重新加载，但仍会生成新的历史记录</code></p><p>END</p>`,40),e=[t];function i(p,c,r,h,d,u){return s(),o("div",null,e)}const g=l(n,[["render",i]]);export{E as __pageData,g as default};
