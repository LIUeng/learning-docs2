import{_ as s,o as l,c as a,Q as n}from"./chunks/framework.7c0fadea.js";const h=JSON.parse('{"title":"数据结构辅助记忆","description":"","frontmatter":{},"headers":[],"relativePath":"alogrithm/interview/self.md","filePath":"alogrithm/interview/self.md","lastUpdated":1694490311000}'),e={name:"alogrithm/interview/self.md"},p=n(`<h1 id="数据结构辅助记忆" tabindex="-1">数据结构辅助记忆 <a class="header-anchor" href="#数据结构辅助记忆" aria-label="Permalink to &quot;数据结构辅助记忆&quot;">​</a></h1><blockquote><p>适合自己的数据结构与算法的记忆方法</p></blockquote><h2 id="常见的数据结构" tabindex="-1">常见的数据结构 <a class="header-anchor" href="#常见的数据结构" aria-label="Permalink to &quot;常见的数据结构&quot;">​</a></h2><h3 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h3><p>小顶堆 大顶堆</p><ul><li>数组存储</li><li>左字节点下标 i 对应的父节点为 2 * i + 1</li><li>右字节点下标 i 对应的父节点为 2 * i + 2</li><li>建堆 <ul><li>自下向顶（递归父节点）</li><li>自顶向下（递归左右子节点）</li></ul></li><li>删除 <ul><li>删除的元素（相同的元素）</li><li>最后一个元素替换删除元素</li><li>重新建堆 <ul><li>没有左节点 自下向顶</li><li>有左节点且（没有父节点或者当前删除的节点与父节点比较）自顶向下</li></ul></li></ul></li><li>实例方法 <ul><li>insert</li><li>delete</li><li>find</li></ul></li><li>堆排序 <ul><li>每次取堆顶元素，重新向下建堆</li><li>直到堆为空</li></ul></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 建堆</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Heap</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">v</span><span style="color:#E1E4E8;">) {}</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">() {},</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">heapifyUp</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">) {}</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">heapifyDown</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">) {}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 建堆</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Heap</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#E36209;">v</span><span style="color:#24292E;">) {}</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">() {},</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">heapifyUp</span><span style="color:#24292E;">(</span><span style="color:#E36209;">index</span><span style="color:#24292E;">) {}</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">heapifyDown</span><span style="color:#24292E;">(</span><span style="color:#E36209;">index</span><span style="color:#24292E;">) {}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="hash-表" tabindex="-1">Hash 表 <a class="header-anchor" href="#hash-表" aria-label="Permalink to &quot;Hash 表&quot;">​</a></h3><ul><li>设计 hash 算法 <ul><li>大小</li><li>存储方式（链表）</li></ul></li><li>实例方法 <ul><li>set</li><li>get</li><li>has</li><li>delete</li><li>getKeys</li><li>getValues</li></ul></li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HashTable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">size</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.keys </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {};</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.buckets </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;">(size).</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">bucket</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">/* ... */</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HashTable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">size</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.keys </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {};</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.buckets </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;">(size).</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">((</span><span style="color:#E36209;">bucket</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">/* ... */</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="字典树" tabindex="-1">字典树 <a class="header-anchor" href="#字典树" aria-label="Permalink to &quot;字典树&quot;">​</a></h3><p>Trie</p><ul><li>实例方法 <ul><li>addWord</li><li>deleteWord --- 深度优先遍历（递归）</li><li>suggestNextCharacters</li><li>doesWordExist</li></ul></li><li>每个节点的属性 <ul><li>character</li><li>children --- HashTable</li><li>isCompleteWord</li></ul></li></ul><h3 id="图" tabindex="-1">图 <a class="header-anchor" href="#图" aria-label="Permalink to &quot;图&quot;">​</a></h3><p>Graph</p><blockquote><p>无向图 有向图</p></blockquote><ul><li>顶点 <ul><li>当前顶点值</li><li>存储（链表）</li></ul></li><li>边 <ul><li>开始顶点</li><li>结束顶点</li></ul></li></ul><h4 id="探测环" tabindex="-1">探测环 <a class="header-anchor" href="#探测环" aria-label="Permalink to &quot;探测环&quot;">​</a></h4><blockquote><p>无向图探测</p></blockquote><ul><li>记录访问过的顶点，以及各个顶点对应的前一个顶点 <ul><li>visited parents</li></ul></li><li>注意判断成环的条件</li><li>利用以上变量遍历返回成环的对象</li></ul><blockquote><p>有向图探测</p></blockquote><p>变量含义</p><ol><li>white set 所有的顶点</li><li>gray set 记录进入时访问的节点</li><li>black set 记录离开时访问的节点</li></ol><ul><li>记录访问的当前节点以及对应的父亲节点</li><li>判断是否继续遍历的条件 <ul><li>!black[next]</li></ul></li><li>存在 gray set 访问过的节点即存在环</li></ul><h3 id="disjoin-set" tabindex="-1">Disjoin Set <a class="header-anchor" href="#disjoin-set" aria-label="Permalink to &quot;Disjoin Set&quot;">​</a></h3><p>交并集</p><ul><li>检测图是否存在环</li></ul><h3 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h3><ul><li>prepend</li><li>append</li><li>insert</li><li>delete</li><li>find</li><li>deleteTail</li><li>deleteHead</li><li>fromArray</li><li>toArray</li><li>toString</li><li>reverse</li></ul><h4 id="链表倒转" tabindex="-1">链表倒转 <a class="header-anchor" href="#链表倒转" aria-label="Permalink to &quot;链表倒转&quot;">​</a></h4><p>前后变量法</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> nextNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> prevNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (currNode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  nextNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currNode.next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  currNode.next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> prevNode;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// doubly linked node if</span></span>
<span class="line"><span style="color:#E1E4E8;">  currNode.prev </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  prevNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> currNode;</span></span>
<span class="line"><span style="color:#E1E4E8;">  currNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextNode;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> nextNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> prevNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (currNode) {</span></span>
<span class="line"><span style="color:#24292E;">  nextNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currNode.next;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  currNode.next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> prevNode;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// doubly linked node if</span></span>
<span class="line"><span style="color:#24292E;">  currNode.prev </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  prevNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> currNode;</span></span>
<span class="line"><span style="color:#24292E;">  currNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextNode;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-label="Permalink to &quot;树&quot;">​</a></h3><p>二叉树</p><ul><li>BinarySearchTree <ul><li>insert</li><li>contains</li><li>remove</li><li>toString</li></ul></li><li>BinarySearchTreeNode <ul><li>insert</li><li>find</li><li>contains</li><li>remove</li><li>findMin</li></ul></li><li>BinaryTreeNode <ul><li>get leftHeight</li><li>get rightHeight</li><li>get height</li><li>get balanceFactor</li><li>get uncle</li><li>setValue</li><li>setLeft</li><li>setRight</li><li>removeChild</li><li>replaceChild</li><li>static copyNode</li><li>traverseInOrder</li><li>toString</li></ul></li></ul><h4 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h4><ul><li>删除节点 <ul><li>存在左右节点 <ul><li>右节点需要寻找最小节点作为当前删除节点</li></ul></li><li>不存在左右节点</li><li>存在其中一个节点（左右）</li></ul></li><li>遍历 <ul><li>前序遍历（根 左 右）</li><li>中序遍历（左 根 右）</li><li>后续遍历（左 右 根）</li></ul></li><li>计算当前节点的高度 <ul><li>递归寻找</li></ul></li></ul>`,37),o=[p];function i(t,r,c,E,y,d){return l(),a("div",null,o)}const b=s(e,[["render",i]]);export{h as __pageData,b as default};
