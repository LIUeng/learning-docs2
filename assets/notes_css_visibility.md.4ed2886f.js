import{_ as a,o as l,c as s,Q as i}from"./chunks/framework.7c0fadea.js";const b=JSON.parse('{"title":"visibility","description":"","frontmatter":{},"headers":[],"relativePath":"notes/css/visibility.md","filePath":"notes/css/visibility.md","lastUpdated":1670330848000}'),n={name:"notes/css/visibility.md"},t=i(`<h1 id="visibility" tabindex="-1">visibility <a class="header-anchor" href="#visibility" aria-label="Permalink to &quot;visibility&quot;">​</a></h1><p>css 中控制显示隐藏的属性</p><h2 id="display" tabindex="-1">display <a class="header-anchor" href="#display" aria-label="Permalink to &quot;display&quot;">​</a></h2><ul><li>none/block</li></ul><ul><li>控制元素的显隐，破坏渲染状态（代价比较高）；none 独立文档之外，不占空间大小</li></ul><h2 id="visibility-1" tabindex="-1">visibility <a class="header-anchor" href="#visibility-1" aria-label="Permalink to &quot;visibility&quot;">​</a></h2><ul><li>visible/hidden</li></ul><ul><li>隐藏元素并保持自身的渲染状态，dom 事件依然可行，空间大小依然占据（物理上显示空白）</li></ul><h2 id="content-visibility" tabindex="-1">content-visibility <a class="header-anchor" href="#content-visibility" aria-label="Permalink to &quot;content-visibility&quot;">​</a></h2><p>chrome85+ 兼容</p><ul><li>visible/hidden/auto</li></ul><ul><li>跳过屏幕之外的元素，不渲染以达到首次加载渲染速度</li><li>隐藏元素并保持自身的渲染状态，dom 操作、空间大小随着元素的显隐（显示即可操作，隐藏不可操作）</li></ul><ul><li>contain-intrinsic-size 包含固有的大小（当隐藏时仍然保有设置的大小的空间，元素空间显示为空）</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">.container</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">content-visibility</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">auto</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">contain-intrinsic-size</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#F97583;">px</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">.container</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">content-visibility</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">auto</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">contain-intrinsic-size</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#D73A49;">px</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="contain" tabindex="-1">contain <a class="header-anchor" href="#contain" aria-label="Permalink to &quot;contain&quot;">​</a></h2><p>Chrome 52+ Opera 40+ 兼容</p><ul><li>允许限制元素的渲染范围</li></ul><h3 id="size" tabindex="-1">size <a class="header-anchor" href="#size" aria-label="Permalink to &quot;size&quot;">​</a></h3><ul><li>元素的子元素不会影响父元素的大小，推断和设置的尺寸是使用的尺寸（性能优化不是太多）</li></ul><h3 id="layout" tabindex="-1">layout <a class="header-anchor" href="#layout" aria-label="Permalink to &quot;layout&quot;">​</a></h3><ul><li>包含元素相对于布局来说是完全透明的，任何外部都不能影响内部布局</li><li>更改元素的布局，可能要检查整个DOM的元素，使用 contain: layout 可以减少检查元素的个数，达到优化效果</li></ul><h3 id="style" tabindex="-1">style <a class="header-anchor" href="#style" aria-label="Permalink to &quot;style&quot;">​</a></h3><ul><li>样式更改不会传播回包含元素（e.g. css counters 计数器的使用）</li></ul><h3 id="paint" tabindex="-1">paint <a class="header-anchor" href="#paint" aria-label="Permalink to &quot;paint&quot;">​</a></h3><ul><li>包含元素的后代不会显示在其边界之外</li></ul><blockquote><p>effects</p></blockquote><ol><li>充当绝对定位和固定位置元素的包含块（任何子元素都基于元素定位）</li><li>形成堆叠上下文（z-index 对元素产生了影响，子元素将根据新的上下文堆叠）</li><li>形成一个新的格式化上下文</li></ol><h3 id="组合使用" tabindex="-1">组合使用 <a class="header-anchor" href="#组合使用" aria-label="Permalink to &quot;组合使用&quot;">​</a></h3><p>contain: strict ==== contain: size layout paint</p><ul><li>提前知道元素的尺寸，可以使用严格模式</li></ul><p>contain: content ==== contain: layout paint</p><ul><li>content 默认行为</li></ul>`,32),e=[t];function o(c,p,r,u,d,y){return l(),s("div",null,e)}const E=a(n,[["render",o]]);export{b as __pageData,E as default};
