import{_ as a,o as e,c as l,Q as o}from"./chunks/framework.7c0fadea.js";const m=JSON.parse('{"title":"HTTPS 加密层","description":"","frontmatter":{},"headers":[],"relativePath":"network/tls_ssl.md","filePath":"network/tls_ssl.md","lastUpdated":1670330848000}'),i={name:"network/tls_ssl.md"},t=o('<h1 id="https-加密层" tabindex="-1">HTTPS 加密层 <a class="header-anchor" href="#https-加密层" aria-label="Permalink to &quot;HTTPS 加密层&quot;">​</a></h1><p><a href="https://time.geekbang.org/column/article/156181" target="_blank" rel="noreferrer">参考链接</a></p><p>HTTP - TLS/SSL - TCP - IP - 数据链路层</p><p><code>HTTP 数据传输加密过程</code></p><blockquote><p>加密套件列表</p></blockquote><p>浏览器支持的加密方式有多少种</p><h2 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h2><ol><li>浏览器发送对称加密套件列表和 client-random 随机数</li><li>服务器收到加密套件列表，选择加密方式和 service-random 随机数，返回给浏览器</li><li>浏览器和服务器返回确认信息</li></ol><h3 id="计算密钥" tabindex="-1">计算密钥 <a class="header-anchor" href="#计算密钥" aria-label="Permalink to &quot;计算密钥&quot;">​</a></h3><blockquote><p>密钥都能用来解密</p></blockquote><ol><li>浏览器和服务器都有 client-random 和 service-random</li><li>浏览器和服务器使用相同的方法对 client-random 和 service-random 混合起来生成密钥 master-secret</li><li>使用 master-secret 加密传输数据</li></ol><h3 id="缺陷" tabindex="-1">缺陷 <a class="header-anchor" href="#缺陷" aria-label="Permalink to &quot;缺陷&quot;">​</a></h3><blockquote><p>client-random 和 service-random 都是明文的，拿到随机数和加密方式，以及利用随机数的生成密钥的算法都是公开的，也可以生成密钥来解析数据</p></blockquote><h2 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h2><blockquote><p>非对称，公钥只有私钥能解密，私钥只有公钥能解密</p></blockquote><ol><li>浏览器发送非对称加密套件列表</li><li>服务收到非对称加密套件列表，返回加密方式和公钥</li><li>浏览器和服务器返回确认信息</li></ol><h3 id="加密数据" tabindex="-1">加密数据 <a class="header-anchor" href="#加密数据" aria-label="Permalink to &quot;加密数据&quot;">​</a></h3><ol><li>浏览器使用公钥加密数据</li><li>私钥只有服务器存在，利用私钥解密数据</li></ol><h3 id="缺陷-1" tabindex="-1">缺陷 <a class="header-anchor" href="#缺陷-1" aria-label="Permalink to &quot;缺陷&quot;">​</a></h3><ol><li>非对称加密算法效率太慢，影响数据传输速率</li><li>无法保证服务器发送给浏览器的数据安全（公钥是可以被拦截获取的）</li></ol><h2 id="对称加密-非对称加密" tabindex="-1">对称加密 + 非对称加密 <a class="header-anchor" href="#对称加密-非对称加密" aria-label="Permalink to &quot;对称加密 + 非对称加密&quot;">​</a></h2><blockquote><p>HTTPS 采用混合加密方式进行数据的加密</p></blockquote><ol><li>浏览器发送加密套件列表、非对称加密套件列表以及 client-random 随机数</li><li>服务器收到消息，选择加密方式以及生成公钥和 service-random 随机数</li><li>浏览器保存公钥，并生成随机数 pre-master</li><li>使用公钥加密 pre-master 发送给服务器确认 master-secret</li><li>服务器浏览器确认返回信息</li></ol><h3 id="加密数据-1" tabindex="-1">加密数据 <a class="header-anchor" href="#加密数据-1" aria-label="Permalink to &quot;加密数据&quot;">​</a></h3><ol><li>浏览器和服务器都拥有 client-random、service-random 以及 pre-master 三组随机数</li><li>使用三组随机数生成对称密钥，就可以使用对称加密方式传输数据</li></ol><h3 id="安全性" tabindex="-1">安全性 <a class="header-anchor" href="#安全性" aria-label="Permalink to &quot;安全性&quot;">​</a></h3><blockquote><p>获取到 pre-master 随机数，但是是经过公钥加密过的，只有私钥才能解密</p></blockquote><h2 id="ca-证书" tabindex="-1">CA 证书 <a class="header-anchor" href="#ca-证书" aria-label="Permalink to &quot;CA 证书&quot;">​</a></h2><blockquote><p>有了混合加密方式的传输数据仍然不是安全的（DNS 劫持替换 IP 地址）</p></blockquote><h3 id="加密方式" tabindex="-1">加密方式 <a class="header-anchor" href="#加密方式" aria-label="Permalink to &quot;加密方式&quot;">​</a></h3><ol><li>浏览器发送加密套件列表、非对称加密套件列表以及 client-random 随机数</li><li>服务器收到消息，选择加密方式以及返回<code>数字证书</code>和 service-random 随机数</li><li>浏览器获取数字证书中的公钥，并生成随机数 pre-master</li><li>使用公钥加密 pre-master 发送给服务器确认 master-secret</li><li>服务器浏览器确认返回信息</li></ol><h3 id="申请数字证书" tabindex="-1">申请数字证书 <a class="header-anchor" href="#申请数字证书" aria-label="Permalink to &quot;申请数字证书&quot;">​</a></h3><ol><li>准备一套公钥和私钥，私钥留着自己使用</li><li>向 CA 机构提交公钥以及相关信息（收费）</li><li>CA 机构验证信息是否合理合法</li><li>信息审核通过，签发数字证书（公钥、组织信息、CA 的信息、有效时间、证书序列号等明文信息）以及一个 CA 生成的签名</li></ol><h3 id="ca-数字签名" tabindex="-1">CA 数字签名 <a class="header-anchor" href="#ca-数字签名" aria-label="Permalink to &quot;CA 数字签名&quot;">​</a></h3><ol><li>CA 使用 Hash 函数算法计算明文信息，并得出信息摘要</li><li>CA 使用其自有的私钥对信息摘要进行加密，加密后的密文就是数字签名</li></ol><h3 id="验证数字证书" tabindex="-1">验证数字证书 <a class="header-anchor" href="#验证数字证书" aria-label="Permalink to &quot;验证数字证书&quot;">​</a></h3><ol><li>浏览器使用相同的 Hash 算法函数计算明文信息，得到信息摘要 A</li><li>再使用公钥对数字签名解密，得到信息摘要 B</li><li>信息摘要 A === 信息摘要 B</li></ol><blockquote><p>CA 是机构，会沿着 CA 机构链查找，直到根证书机构为止（否则视为不合法）</p></blockquote><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ol><li>申请数字证书是不需要提供私钥的，私钥永远只能存在于服务器上</li><li>数字证书最核心的内容就是使用其自有的私钥生成的数字签名</li><li>内置 CA 对应的证书称为根证书，最权威的机构（自签名证书）</li></ol><h2 id="数字证书拓展" tabindex="-1">数字证书拓展 <a class="header-anchor" href="#数字证书拓展" aria-label="Permalink to &quot;数字证书拓展&quot;">​</a></h2><p>数字证书</p><blockquote><p>个人申请的证书属于 DV 类型；普通公司申请的证书属于 OV 类型；金融机构、银行、电商平台申请的证书属于 EV 类型（DV 自动验证，OV 和 EV 需要人工验证）</p></blockquote><blockquote><p>CA 机构的权威性，数字证书链，中间 CA(Intermediates CAs)和根 CA(Root CAs)</p></blockquote><blockquote><p>操作系统内置根证书，WebTrust（网络信任） 认证是电子认证服务行业中唯一的国际性认证标准（认证的根 CA 目前有 Comodo，geotrust，rapidssl，symantec，thawte，digicert），只有在操作系统中能追溯到数字证书链才能验证证书合法</p></blockquote>',45),r=[t];function c(s,n,h,d,u,b){return e(),l("div",null,r)}const p=a(i,[["render",c]]);export{m as __pageData,p as default};
