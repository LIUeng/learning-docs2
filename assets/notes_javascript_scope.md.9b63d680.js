import{_ as s,o as a,c as l,Q as n}from"./chunks/framework.7c0fadea.js";const u=JSON.parse('{"title":"JS 作用域","description":"","frontmatter":{},"headers":[],"relativePath":"notes/javascript/scope.md","filePath":"notes/javascript/scope.md","lastUpdated":1670330848000}'),o={name:"notes/javascript/scope.md"},p=n(`<h1 id="js-作用域" tabindex="-1">JS 作用域 <a class="header-anchor" href="#js-作用域" aria-label="Permalink to &quot;JS 作用域&quot;">​</a></h1><p>JavaScript 动态（解释执行）语言，不是提前编译的，编译结果也不能在分布式系统上移植</p><h2 id="编译原理" tabindex="-1">编译原理 <a class="header-anchor" href="#编译原理" aria-label="Permalink to &quot;编译原理&quot;">​</a></h2><ol><li>分词/词法分析</li></ol><ul><li>词法最小单元（token） var, a, =, 1</li></ul><ol start="2"><li>解析/语法分析</li></ol><ul><li>解析成抽象语法树</li></ul><ol start="3"><li>代码生成</li></ol><ul><li>将 AST 转换位可执行代码</li></ul><blockquote><p>负责收据并维护所有声明的标识符（变量）的一系列查询，并有一定的规则来赋予这些标识符的访问权限</p></blockquote><h2 id="理解作用域" tabindex="-1">理解作用域 <a class="header-anchor" href="#理解作用域" aria-label="Permalink to &quot;理解作用域&quot;">​</a></h2><blockquote><p>程序中定义变量的区域，该位置决定了变量的生命周期 变量和函数的可访问范围，作用域控制着变量的可见性与生命周期</p></blockquote><h3 id="lhs-rhs" tabindex="-1">LHS RHS <a class="header-anchor" href="#lhs-rhs" aria-label="Permalink to &quot;LHS RHS&quot;">​</a></h3><p>赋值操作的左侧或右侧</p><ul><li>LHS(赋值操作的目标是谁)</li><li>RHS(谁是赋值操作的源头)</li></ul><h3 id="异常" tabindex="-1">异常 <a class="header-anchor" href="#异常" aria-label="Permalink to &quot;异常&quot;">​</a></h3><ul><li>查询到作用域，引用值 null 或 undefined，TypeError</li><li>未查询到作用域，ReferenceError</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）</li><li>查找的目的是为了给变量赋值，就会使用 LHS 查询</li><li>获取变量的值，使用 RHS 查询</li><li>不成功的 RHS 引用会导致 ReferenceError 异常</li></ul><p><code>作用域链</code></p><blockquote><p>通过作用域来查找变量的链条称为作用域链</p></blockquote><ul><li>作用域链保证对执行环境有权访问（变量函数的有序访问）</li><li>指向变量对象 =&gt; 变量对象包含执行环境所有变量和函数的对象（当前执行上下文的变量对象）</li></ul><h2 id="词法作用域" tabindex="-1">词法作用域 <a class="header-anchor" href="#词法作用域" aria-label="Permalink to &quot;词法作用域&quot;">​</a></h2><blockquote><p>代码编译阶段就决定好，和函数如何调用的没关系 词法阶段的作用域(将变量和块作用域写在哪里决定的) 作用域是由代码中函数声明的位置来决定的，词法作用域是静态的作用域 通过词法作用域可以预测代码在执行过程中如何查找变量</p></blockquote><h3 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h3><blockquote><p>词法作用域规定，内部函数可以访问外部函数声明中的变量，当通过调用一个外部函数返回内部函数后，即使该外部函数执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，把这些变量的集合成为闭包</p></blockquote><h3 id="查找作用域" tabindex="-1">查找作用域 <a class="header-anchor" href="#查找作用域" aria-label="Permalink to &quot;查找作用域&quot;">​</a></h3><ul><li>全局环境作用域</li><li>所执行的环境作用域</li></ul><blockquote><p>作用域查找会在找到第一个匹配的标识符停止（遮蔽效应） 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者向上进行，直到遇见第一个匹配的标识符为止</p></blockquote><h3 id="欺骗作用域" tabindex="-1">欺骗作用域 <a class="header-anchor" href="#欺骗作用域" aria-label="Permalink to &quot;欺骗作用域&quot;">​</a></h3><blockquote><p>eval with 会干扰作用域，降低性能</p></blockquote><h4 id="eval" tabindex="-1">eval <a class="header-anchor" href="#eval" aria-label="Permalink to &quot;eval&quot;">​</a></h4><p>接收一个字符串作为参数，可以执行字符串代码（动态生成的函数代码）</p><ul><li>严格模式中，eval 拥有自己的作用域，无法改变所在的作用域</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">str</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;use strict&#39;</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 无法改变所在的作用域 输入 ReferenceError: a is not defined</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">eval</span><span style="color:#E1E4E8;">(str);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(a); </span><span style="color:#6A737D;">// 改变了全局作用域 输出 1</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;var a = 1&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">(</span><span style="color:#E36209;">str</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;use strict&#39;</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 无法改变所在的作用域 输入 ReferenceError: a is not defined</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">eval</span><span style="color:#24292E;">(str);</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a); </span><span style="color:#6A737D;">// 改变了全局作用域 输出 1</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;var a = 1&#39;</span><span style="color:#24292E;">);</span></span></code></pre></div><h4 id="with" tabindex="-1">with <a class="header-anchor" href="#with" aria-label="Permalink to &quot;with&quot;">​</a></h4><blockquote><p>重复引用一个对象的多个属性的快捷方式</p></blockquote><ul><li>作用域泄露</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">with</span><span style="color:#E1E4E8;">(obj) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  a: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">(o1); </span><span style="color:#6A737D;">// o1.a = 2</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  b: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">(o2); </span><span style="color:#6A737D;">// o2.a = undefind</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(a) </span><span style="color:#6A737D;">// 2 由于 o2 对象中没有 a 属性，导致 with 作用域中 a = 2 改变了全局作用域</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">(</span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">with</span><span style="color:#24292E;">(obj) {</span></span>
<span class="line"><span style="color:#24292E;">    a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> o1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  a: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">(o1); </span><span style="color:#6A737D;">// o1.a = 2</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> o2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  b: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#6F42C1;">foo</span><span style="color:#24292E;">(o2); </span><span style="color:#6A737D;">// o2.a = undefind</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(a) </span><span style="color:#6A737D;">// 2 由于 o2 对象中没有 a 属性，导致 with 作用域中 a = 2 改变了全局作用域</span></span></code></pre></div><h4 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h4><blockquote><p>JavaScript 在编译阶段会进行性能优化（代码的词法进行静态分析、预先确定所有变量和函数的位置），而 eval 和 with 会导致标识符的位置是无效的，从而导致性能降低</p></blockquote><div class="warning custom-block"><p class="custom-block-title">注意</p><p>在严格模式中，eval(警告 unsafe-eval)，with 无法使用</p></div><h3 id="全局作用域" tabindex="-1">全局作用域 <a class="header-anchor" href="#全局作用域" aria-label="Permalink to &quot;全局作用域&quot;">​</a></h3><h3 id="函数作用域" tabindex="-1">函数作用域 <a class="header-anchor" href="#函数作用域" aria-label="Permalink to &quot;函数作用域&quot;">​</a></h3><h3 id="块级作用域" tabindex="-1">块级作用域 <a class="header-anchor" href="#块级作用域" aria-label="Permalink to &quot;块级作用域&quot;">​</a></h3><p>块级作用域是通过词法环境的栈结构实现的，而变量提升是通过变量环境来实现，两者结合就实现了JavaScript的变量提升和块级作用域</p>`,46),e=[p];function t(c,r,i,E,y,h){return a(),l("div",null,e)}const b=s(o,[["render",t]]);export{u as __pageData,b as default};
